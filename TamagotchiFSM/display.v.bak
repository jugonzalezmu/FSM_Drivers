`timescale 1ns / 1ps
`include "Lab04-Simulation/BCDtoSSeg.v"

// Ya con esto esta para dos displays para mostrar dos numeros de 8 bits como maximo (255 en decimal :v)

module display(
    input [7:0] num1,
	 input [7:0] num2,
    input clk,
    output [0:6] sseg,
    output reg [2:0] an,
	 output reg [2:0] an1,
	 input rst,
	 output led 
    );
	 
//Se ponen con 4 bits por que los numeros que se van a representar necesitan de 4 bits, ejemplo d8=b1000
reg [3:0] digit1_3, digit1_2, digit1_1, digit1_0;
reg [3:0] digit2_3, digit2_2, digit2_1, digit2_0;

reg [5:0]bcd=0;
//wire [15:0] num=16'h4321;
 
BCDtoSSeg bcdtosseg(.BCD(bcd), .SSeg(sseg));

reg [26:0] cfreq=0;
wire enable;

// Divisor de frecuecia

assign enable = cfreq[16];
assign led =enable;
always @(posedge clk) begin
  if(rst==0) begin
		cfreq <= 0;
	end else begin
		cfreq <=cfreq+1'b1;
	end
end

reg [2:0] count1 = 2'b0;

always @(posedge enable) begin
//Conversión numeros recibidos a decimal
      digit1_2 = ((num1 - (num1 % 100)) / 100) % 10;
      digit1_1 = ((num1 - (num1 % 10)) / 10) % 10;
      digit1_0 = num1 % 10;

      digit2_2 = ((num2 - (num2 % 100)) / 100) % 10;
      digit2_1 = ((num2 - (num2 % 10)) / 10) % 10;
      digit2_0 = num2 % 10;

		if(rst==0) begin
			count1<= 0;
			an<=4'b1111; 
			an1<=4'b1111; 
		end else begin 
			an<=4'b0111; 
			an1<=4'b0111; 
			
			case (count1) 
//bcd obtiene el valor que se va a representar en el display, el 0 de an y an1 indica cual de los displays va a estar prendindo y el 1 cuales estarán apagados.
//Solo se tienen 6 casos porque solo se usarán 6 displays.
				3'h0: begin bcd <= digit1_0;   an<=3'b110; end 
				3'h1: begin bcd <= digit1_1;   an<=3'b101; end 
				3'h2: begin bcd <= digit1_2;   an<=3'b011; end 
				3'h3: begin bcd <= digit2_0;   an1<=3'b110; end 
				3'h4: begin bcd <= digit2_1;   an1<=3'b101; end 
				3'h5: begin bcd <= digit2_2;   an1<=3'b011; end 
			endcase
			count1<= count1+1;
			if(count1==6) begin
				count1<=0;
			end
		end 
end

endmodule